## 功能介绍

SDK为高级VIP用户提供反外挂检测接口功能，将检测到的用户作弊信息以实时广播的形式同步给游戏侧。游戏项目组可以根据检测结果，自行处理制定作弊打击策略，实现反外挂的自由可控与高度定制化。

**特别说明**

```xml
1、关于SDK版本： SDK3.8.9及以上版本开始支持该功能；
2、支持的开发语言： SDK提供C#、Java、C++三种形式的接口，开发者可任选一种语言来完成接入；
3、SDK接入： 在阅读本文之前，确保已经正确接入了其他SDK接口；
4、关于广播数据类型：SDK4.0.2及以上版本支持检测结果含有id = 10，11，12的广播数据；
                   SDK4.2及以上版本支持检测结果含有id = 13的广播数据；
                   SDK4.7及以上版本支持检测结果含有id = 14, 15, 16, 17, 18的广播数据；
                   SDK4.8及以上版本支持检测结果含有id = 19的广播数据
5. 建议将广播数据传到服务器端，然后由服务器端结合玩家举报、战绩、投诉等指标进行策略准确性
   评估后做出运营决策，切不可将广播数据直接作为唯一处罚依据。
6. 后续实时反外挂的扫描结果也会以广播id = 13的形式同步给游戏侧。
7. 涉及到游戏如何自定义策略，建议咨询客服获取白皮书。
```

## 接口说明

【Java】

```java

public class TssInfoPublisher implements Runnable{

    // 检测结果
    public static final int TSS_INFO_TYPE_DETECT_RESULT = 1;

    // 心跳数据
    public static final int TSS_INFO_TYPE_HEARTBEAT = 2;

    // 开发者需要自己实现TssInfoReceiver接口
    public interface TssInfoReceiver{

        public void onReceive(int tssInfoType,String info);

    }
}

public class TP2Sdk {

    // 开发者使用该函数注册自己实现的接口
    public static void registTssInfoReceiver(TssInfoPublisher.TssInfoReceiver receiver){

        TssSdk.registTssInfoReceiver(receiver);

    }

    // 将收到的信息使用该接口解密
    public static String decTssInfo(String info){

        return TssSdk.decTssInfo(info);
    }
}
```

【C++版本】

接口源码文件tp2_sdk.h

```c++
// 信息类型

enum TssInfoType{

    TSS_INFO_TYPE_DETECT_RESULT = 1, // 检测结果

    TSS_INFO_TYPE_HEARTBEAT = 2, // 心跳信息

};

// 开发者需要自己继承类TssInfoReceiver 实现onReceive函数
class TssInfoReceiver{

    public:
    virtual ~TssInfoReceiver(){}

    virtual int getInterfaceVersionCode(){return 1;}

    virtual void onReceive(int tssInfoType,const char* info) = 0;
};

// ...

// 使用此接口注册自己实现的TssInfoReceiver
void tp2_regist_tss_info_receiver(TssInfoReceiver* receiver);

// 将收到的信息使用该接口解密
int tp2_dec_tss_info(const char* src,char* out,size_t len);
```

【C#版本】

c# 接口文件tp2.cs

```csharp

namespace tss{

    // 开发者实现TssInfoReceiver接口
    public interface TssInfoReceiver{

        void onReceive(int tssInfoType,string info);

    }

    public class TssInfoPublisher{
        // 反外挂作弊检测数据
        public const int TSS_INFO_TYPE_DETECT_RESULT = 1;
        // 防剥离心跳数据
        public const int TSS_INFO_TYPE_HEARTBEAT = 2;

        // ...

    }
}


public static class Tp2Sdk{
    // ...

    // 使用Tp2RegistTssInfoReceiver注册开发者实现的TssInfoReceiver接口

    public static void Tp2RegistTssInfoReceiver(tss.TssInfoReceiver receiver){

        tss.TssInfoPublisher.getInstance ().registTssInfoReceiver (receiver);

    }


    // 将收到的信息使用该接口解密
    public static string Tp2DecTssInfo(string info){

        string cmd = String.Format("dec_tss_info:{0}",info);

        return Tp2Ioctl(cmd);
    }
// ...
}

```

## 反外挂检测数据格式

**TSS_INFO_TYPE_DETECT_RESULT**

```c++
enum TP2GameStatus{
    TSS_INFO_TYPE_DETECT_RESULT_ANO = 1,
    TSS_INFO_TYPE_DETECT_RESULT_APPFORBID = 2,
    TSS_INFO_TYPE_DETECT_RESULT_GP4 = 3,
    TSS_INFO_TYPE_DETECT_RESULT_GP3 = 4,
    TSS_INFO_TYPE_DETECT_RESULT_VP2 = 5,
    TSS_INFO_TYPE_DETECT_RESULT_VP3 = 6,
    TSS_INFO_TYPE_DETECT_RESULT_TS2 = 7,
    TSS_INFO_TYPE_DETECT_RESULT_EMULATOR = 8,
    TSS_INFO_TYPE_DETECT_RESULT_FORTEST = 9,
    TSS_INFO_TYPE_DETECT_COMMON_INFO = 10,
    TSS_INFO_TYPE_DETECT_SO_REPLACED = 11,
    TSS_INFO_TYPE_DETECT_SUSPICIOUS_APK = 12,
    TSS_INFO_TYPE_DETECT_LUA_REPORT = 13,
    TSS_INFO_TYPE_DETECT_CHECK_HOST = 14,
    TSS_INFO_TYPE_DETECT_CHECK_PERMISSION = 15,
    TSS_INFO_TYPE_DETECT_MALWARES = 16,
    TSS_INFO_TYPE_SUS_MODULE = 17,
    TSS_INFO_TYPE_DETECT_SHELL_STR = 18,
    TSS_INFO_TYPE_DETECT_RESULT_CLOUDPHONE = 19,
    TSS_INFO_TYPE_DETECT_RESULT_LIVE = 20,
    TSS_INFO_TYPE_DETECT_CRACK_CERT = 21,
}
```

```xml
1、接收的所有信息都是一个字符串，字符串格式:"id=value|key=value|key=value|..."。
2、每个字符串至少包含一个名为id的key，用于区分是哪种检测结果。
3、为了保证代码对新版SDK的兼容性，
每个字符串应该采用key=value字典形式解析，不要假设键值对的顺序是不变的，
在新版本的SDK上可能会新增新的广播id，或者在现有广播中以任意的顺序插入新增的键值对。
4、检测频率：大部分扫描相关的数据是每5min产生一次
```

**21种类型检测结果信息**

* id=1 二选一功能

```xml
格式：id=1|name=外挂包名|...
    name：比如name=catch_.me_.if_.you_.can_
    feature=外挂唯一标识，例如：VP_开头的特征对应的是虚拟机类型外挂
    cert_crc=应用证书crc
    size=APK大小
    install_t=apk安装时间
备注：只要收到该信息，可确认玩家设备上安装了已知外挂样本
```

* id=2 应用列表权限检测

```xml
格式：id=2
备注：只要收到该信息，可确认应用列表权限被禁止或设别上只安装了一个APP（除系统之外）,若应用权限列表被禁止会导致二选一功能失效
```

* id=3 修改器检测

```xml
格式：id=3|reason=检测到内存访问原因|root=是否root
    reason：可能是修改器的包名，可能是主动防御系统失效等
        reason="604"：对应可疑修改器检测,表示只检测到了修改行为。
        reason="gp3_exception"：检测到修改行为且反调试子系统异常。
        reason="gp4_w3"：检测到修改行为且游戏进程的私有目录权限异常。
        reason="app_forbid"：检测到修改行为且安全列表权限被禁止。
        reason=其他：可能是进程名，也可能是修改器包名。
    root=1表示设备已root，root=0表示设备未root
备注：只要收到该信息，可确认游戏内存被读写
```

* id=4 反调试安全检测

```xml
格式：id=4|reason=反调试系统异常描述信息
    reason：目前返回2种异常信息
        reason=safe ptrace exception：外挂卡住了ptrace使反调试系统启动失败
        reason=tracer scanner exception：反调试系统成功启动后,被外挂攻击
备注：只要收到该信息,可确认反调试系统异常
```

* id=5 虚拟机2.5层、2层检测

```xml
格式：id=5|name=虚拟机包名|...
    name：如name=com.lulu.lulubox
    feature=VA，说明基于行为判断
    cert_md5=应用证书md5
    fake_cert=0表示伪证书
备注：只要收到该信息，说明检测到游戏运行在符合虚拟机特征的工具内
```

* id=6 虚拟机3层检测

```xml
格式：id=6|name=虚拟机包名|...
    name：如name=com.lulu.lulubox
    feature=外挂唯一标识，例如：VP_开头的特征对应的是虚拟机类型外挂
    cert_md5=应用证书md5
    fake_cert=0表示伪证书
备注：只要收到该信息，可确认游戏运行在已知虚拟机样本内
```

* id=7 变速器检测

```xml
格式：id=7|rate=变速倍数|reason=原因
    rate：变速倍数/100 后才是真实的倍率。
    如rate=100变速未变速，rate=150表示加速，倍率为1.5，rate=80变速减速，倍率为0.8。
    reason：可能是变速器进程名，可能是变速器模块名，可能是时间函数被hook
        reason=none：对应可疑变速器检测，即只检测到变速，未检测到变速器的特征（如进程、模块等）
        reason=hook：时间函数被hook
        reason=其他：可能是进程名，可能是模块名
备注：只要收到该信息，可确认游戏变速异常
```

* id=8 模拟器检测

```xml
格式：id=8|name=模拟器名
备注：只要收到该信息，可确认是在模拟器里运行游戏，可参考本平台提供的模拟器数据使用建议
```

* id=9 测试用广播

```xml
格式：id=9|info=foo
备注：此广播在 SDK 启动后 30-60s 内必定触发 1-2 次，用于测试无周期性，不代表任何恶意检测结果
```

* id=10 信息收集

```xml
格式：id=10|root=|...
    root=1表示手机root，root=0表示手机未root
    root_record=1表示手机曾越狱过，root_record=0表示手机未曾越狱过
    x86=0表示为非x86手机，x86=1表示为x86手机
    apk_cnt=数字，表示手机上安装了多少个apk，这个可以用来辅助判断apk列表权限是否被禁
    adb=1,表示手机usb线处于连接状态，adb=0表示手机usb线非处于连接状态。
    machine=手机型号
    sys_ver=系统版本号
    apk_name=当前apk包名
    app_name=当前应用的app名
    app_ver=app版本
    sdk_ver=sdk版本
    files_dir=当前apk的files路径，该数据可以看出apk所处的运行坏境
    sd_dir=应用在sd卡上的目录
    lib_dir为应用的so存在目录
    cert_md5=应用证书md5，用于辅助检测破解版，正常用户的证书md5都是一样的，非正常用户各有各同
    apk_hash_1=应用的安装包hash1，用量的聚集辅助策略制定
    apk_hash_2=应用的安装包hash2，用量的聚集辅助策略制定
    txt_seg_crc=sdk的代码段crc，用于检测被hook的情况，用量的聚集辅助策略制定。
备注：用于辅助策略制定，不管什么情况下都会上报，无论是正常用户还是非正常用户
```

* id=11 so文件被替换

```xml
格式：id=11|name=|size=|crc=|root=
    name=被替换的so文件名称
    size=被替换的so文件大小
    crc=被替换的so文件crc
    root=1表示手机root，root=0表示手机未root
备注：只要收到该信息，说明手机上lib目录下有so文件被替换
```

* id=12 可疑的安装应用

```xml
格式：id=12|name=|feature=|size=|mtime=
    name=外挂包名
    feature=外挂唯一标识，例如：VP_开头的特征对应的是虚拟机类型外挂
    size=apk大小
    mtime=apk最后修改时间
    cert_md5_crc=应用证书md5值的crc
备注：可用量的聚集辅助策略制定
```

* id=13 特征数据上报

```xml
格式：id=13 |...
备注：该广播为实时反外挂模块主动推送的广播，具体格式与含义见所本平台订阅的实时反外挂描述信息。
```

* id=14 域名检测

```xml
格式：id=14|host=被屏蔽的域名
备注：只要接收到该消息，说明检测到通过host文件屏蔽SDK数据通道域名
```

* id=15 缓存目录权限检测

```xml
格式：id=15|path=存在权限异常的文件|permission=权限异常种类
备注：只要接收到该消息，说明检测到缓存目录权限被修改
```

* id=16 可疑的作弊软件检测

```xml
格式：id=16|app_name=作弊软件名
    app_name：比如app_name=com.huang.hl
备注：可用量的聚集辅助策略制定
```

* id=17 可疑注入模块检测

```xml
格式：id=17|name=|...
    name=可疑的模块名称
    size=可疑模块大小
    crc=可疑模块crc
    ext_info=额外的信息，例如模块的最后修改时间
备注：只要收到该消息，说明检测到可疑的模块注入，用于辅助策略制定
```

* id=18 同步壳的信息

```xml
格式：id=18|shell_ver=|...
    shell_ver=壳版本
    apk_path=壳获取到的apk路径，用于辅助检测破解版
    check_state=壳的各个模块的运行状态
备注：用于同步壳获取到的apk路径，不管什么情况下都会上报，无论是正常用户还是非正常用户
```

* id=19 云手机检测
  
```xml
格式：id=19|name=云手机名
    name: 如name=redfinger
备注: 只要收到该消息，可确认检测到云手机
```

* id=20 直播软件检测

```xml
格式：id=20|name=直播软件包名
    name: 如name=com.kwai.livepartner
备注: 只要收到该消息，可确认检测到直播软件
```

* id=21 同步可疑证书检测的信息

```xml
格式：id=21|cert=|author=
    cert=应用证书md5，用于辅助检测破解版，正常用户的证书md5都是一样的，非正常用户各有各同
    author=应用证书作者
备注: 只要收到该消息,说明检测到符合闪退条件的证书信息
```

## 防剥离心跳数据格式

**TSS_INFO_TYPE_HEARTBEAT**

```xml
1、接收的所有信息都是一个字符串，字符串格式："id=value|key=value|key_value|..."
2、每个字符串至少包含一个名为id的key，用于区分是哪种心跳信息
3、目前只有一种类型id=1，用于游戏自己检测SDK的运行状态。
```

```xml
• 格式：id=1|seq=序列号|pid=进程ID|time=手机开机启动时间
    • seq=序列号 序列号从1开始，递增
    • pid=游戏进程id 每次收到的pid应该一致
    • time=手机开机启动时间 采用clock_gettime(CLOCK_MONOTONIC,...)获取。
• 心跳频率：每10s中发送一次数据
• 使用方法：可以通过检查每次收到的数据seq是否递增，pid是否相同来判断SDK状态是否正常
```

## 演示代码

所有可运行的Demo 可以参考SDK包里的demo部分

【Java版本】

```java
public class MainActivity extends Activity {

    // TssInfoReceiver接口实现
    private class MyTssInfoReceiver implements TssInfoPublisher.TssInfoReceiver{

        public void onReceive(int tssInfoType,String info){

            // 将plain字符串数据上传到服务器端，由游戏进行自定义策略
            if (tssInfoType == TssInfoPublisher.TSS_INFO_TYPE_DETECT_RESULT){

            // 只关注TSS_INFO_TYPE_DETECT_RESULT
            String plain = TP2Sdk.decTssInfo(info);

            if (plain.equals("-1")) return;
                Log.d("SDK","[Java TSS INFO]:" + tssInfoType + "|" + plain);
            }else if (tssInfoType == TssInfoPublisher.TSS_INFO_TYPE_HEARTBEAT){

                // 如果不关心心跳信息，可忽略
                String plain = TP2Sdk.decTssInfo(info);
                if (plain.equals("-1")) return;
                Log.d("SDK","[Java TSS INFO]:" + tssInfoType + "|" + plain);
            }
        }

    }

    private MyTssInfoReceiver mTssInfoReceiver;

    @Override
    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);

        // 先于TP2Sdk.initEx执行
        mTssInfoReceiver = new MyTssInfoReceiver();
        TP2Sdk.registTssInfoReceiver(mTssInfoReceiver);
        //登录后第一时间调用init接口, 填写gameId 和 appKey
        TP2Sdk.initEx(9000, "d5ab8dc7ef67ca92e41d730982c5c602");
        // ...
    }
    // ...
}
```

【C++版本】

```c++
// TssInfoReceiver接口实现
class MyTssInfoReceiver:public TssInfoReceiver{

    public:
    virtual void onReceive(int tssInfoType,const char* info){

    char plain[256];
    memset(plain,0x00,sizeof(plain));
    // 将plain字符串数据上传到服务器端，由游戏进行自定义策略
    if (tssInfoType == TSS_INFO_TYPE_DETECT_RESULT){

        // 只关注TSS_INFO_TYPE_DETECT_RESULT
        int ret =tp2_dec_tss_info(info,plain,sizeof(plain));
        if (ret == -1) return;
            __android_log_print(ANDROID_LOG_DEBUG,"SDK",
            "[C++ Cheat Info]:%d|%s", tssInfoType,plain);
    }else if (tssInfoType == TSS_INFO_TYPE_HEARTBEAT){

        // // 处理心跳，如果不关心，可以忽略
        int ret =tp2_dec_tss_info(info,plain,sizeof(plain));
        if (ret == -1) return;
        __android_log_print(ANDROID_LOG_DEBUG,"SDK",
        "[C++ Cheat Info]:%d|%s", tssInfoType,plain);}
    }
};

MyTssInfoReceiver g_tss_info_receiver;

void game_start() {
    // 游戏启动的第一时间调用 先于tp2_sdk_init_ex
    tp2_regist_tss_info_receiver(&g_tss_info_receiver);
    tp2_sdk_init_ex (9000, "d5ab8dc7ef67ca92e41d730982c5c602");

    // 用户登录时调用
    int account_type = ENTRY_ID_QZONE; /*帐号类型*/
    int world_id = 101; /*大区id*/
    char open_id[] = "B73B36366565F9E02C752"; /*与平台相关的用户标识*/
    char role_id[] = "paladin"; /*角色id*/
    tp2_setuserinfo(account_type, world_id, open_id, role_id);
}
```

【C#版本】

```csharp
public class main : MonoBehaviour {

    // TssInfoReceiver接口实现
    private class MyTssInfoReceiver:tss.TssInfoReceiver{

        // 将plain字符串数据上传到服务器端，由游戏进行自定义策略
        public void onReceive(int tssInfoType, string info){

            // 此函数不能被阻塞
            if (tssInfoType == tss.TssInfoPublisher.TSS_INFO_TYPE_DETECT_RESULT) {

                // 处理检测结果 如果不关心，可以忽略
                string plain = Tp2Sdk.Tp2DecTssInfo(info);
                if (plain.Equals("-1")) return;
                Debug.Log ("C# Info:" + tssInfoType + "|" + plain);
            }else if (tssInfoType == tss.TssInfoPublisher.TSS_INFO_TYPE_HEARTBEAT){

                // 处理心跳，如果不关心，可以忽略
                string plain = Tp2Sdk.Tp2DecTssInfo(info);
                if (plain.Equals("-1")) return;
                Debug.Log ("C# Info:" + tssInfoType + "|" + plain);
            }
        }
    }

    private MyTssInfoReceiver mTssInfoReceiver;

    void Awake () {
        // 在游戏启动的第一时间调用 时机先于Tp2SdkInitEx接口
        mTssInfoReceiver = new MyTssInfoReceiver();
        Tp2Sdk.Tp2RegistTssInfoReceiver (mTssInfoReceiver);
        Tp2Sdk.Tp2SdkInitEx(9000, "d5ab8dc7ef67ca92e41d730982c5c602");
        Debug.Log ("C#:main::Awake");
    }
// ...
}
```

## 模拟对照表

模拟器名 | 可能的特征名
--------|------------
腾讯手游助手 | Tencent, Tencent*
雷电 | LeiDian, LeiDian*
夜神 | Nox, NOX605, NOX607, NOX6079, nox
逍遥 | XiaoYao, XiaoYao502, XiaoYao511, XiaoYao5119
网易 | Netease, Netease9, Netease99
靠谱 | KaopuTianTian, KaopuBlueStacks
天天 | TianTian, TianTian9
鲁大师| Ludashi
蓝叠 | BlueStacks, BlueStacks7, BlueStacks255
畅玩 | ChangWan
51  | 51, 51-3
新浪手游助手 | Sina
9981手游助手 | 9981
多玩 | DuoWan
蜻蜓助手| QingTing
叶子猪 | YZZ
海马玩 | Droid4X
手游岛 | ShouYouDao
小皮助手 | XiaoPi
凤凰 | Phoenix1, Phoenix9
蓝光手游大师 | lgshouyou
PEAK | PEAK
CloudMatrix云游戏 | YYX-CloudMatrix
CloudInstanPlay云游戏 | YYX-CloudInstanPlay
东东助手 | DDZS
乐游模拟器 | Leyou
xDroid| xDroid
其它未知 | Unknown, UnknownX86

**说明**

```xml

[^1] * 表示匹配任意字符串，如 Tencent*表示以Tencent开头的字符串
[^2] * 表示匹配任意字符串，如 LeiDian*表示以LeiDian开头的字符串
```

## 云手机对照表

云手机名 | 可能的特征名
--------|------------
蓝光云 | languang
金手指 | goldenfinger
双子星 | gemini
云派 | yunpai
雷电云/多多云 | leidian
红手指 | redfinger
NBE | nbe （红手指工作室专用）
海马云/爱兔云/咪咕 | haima
八门云 | bamen
摩智云 | mozhi
河马云/龙境云 | hema

**说明**

上表中同一个特征名可能对应多个品牌，是因为这些品牌使用了同一云手机平台的服务，技术方案相同，所以识别为相同特征。
